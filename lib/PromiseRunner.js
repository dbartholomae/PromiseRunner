// Generated by CoffeeScript 1.10.0
(function() {
  var DepGraph, Promise, PromiseRunner, winston,
    slice = [].slice;

  Promise = require('bluebird');

  DepGraph = require('dependency-graph').DepGraph;

  winston = require('winston');

  module.exports = PromiseRunner = (function() {
    var cache, determineOrder, isArray, isFunction, load, parseTasks;

    isFunction = function(obj) {
      return typeof obj === 'function';
    };

    isArray = function(obj) {
      return Object.prototype.toString.call(obj) === "[object Array]";
    };

    parseTasks = function(tasks) {
      var task, taskName;
      for (taskName in tasks) {
        task = tasks[taskName];
        winston.debug('Parsing task ' + taskName);
        if (isFunction(task)) {
          winston.debug(' Parsing from function');
          tasks[taskName] = {
            fn: task
          };
        } else if (isArray(task)) {
          winston.debug(' Parsing from array');
          tasks[taskName] = {
            fn: task[0],
            deps: task.slice(1)
          };
        }
        if (tasks[taskName].deps == null) {
          winston.debug(' Adding empty dependency array');
          tasks[taskName].deps = [];
        }
      }
      return tasks;
    };

    determineOrder = function(tasks) {
      var dep, graph, i, len, ref, task, taskName;
      winston.debug("Determining order of tasks " + Object.keys(tasks));
      graph = new DepGraph();
      for (taskName in tasks) {
        task = tasks[taskName];
        winston.debug(" Adding task " + taskName + " to dependency graph");
        graph.addNode(taskName);
        ref = task.deps;
        for (i = 0, len = ref.length; i < len; i++) {
          dep = ref[i];
          winston.debug("  Adding dependency " + dep + " of task " + taskName);
          graph.addNode(dep);
          graph.addDependency(taskName, dep);
        }
      }
      return graph.overallOrder();
    };

    cache = {};

    load = function(taskName, tasks, args) {
      if (cache[taskName] != null) {
        winston.debug("Loading task " + taskName + " from cache");
        return cache[taskName];
      }
      winston.debug("Loading task " + taskName + " by running it");
      return cache[taskName] = Promise.all(tasks[taskName].deps).map(function(dep) {
        winston.debug("  Loading dependency " + dep + " of task " + taskName);
        return load(dep, tasks, args);
      }).then(function(arr) {
        var ref;
        winston.debug("  Dependencies for task " + taskName + " loaded, running task");
        return (ref = tasks[taskName]).fn.apply(ref, arr.concat(args));
      });
    };

    function PromiseRunner(options) {
      if (options == null) {
        options = {};
      }
      this.options = {
        debug: options.debug != null
      };

      /* !pragma coverage-skip-next */
      if (this.options.debug) {
        winston.level = 'debug';
      }
    }

    PromiseRunner.prototype.run = function() {
      var args, error, error1, order, tasks;
      tasks = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      if (tasks == null) {
        throw new Error("No tasks defined");
      }
      winston.debug("Preparing to run tasks " + Object.keys(tasks));
      tasks = parseTasks(tasks);
      winston.debug("Tasks parsed");
      try {
        order = determineOrder(tasks);
      } catch (error1) {
        error = error1;
        return Promise.reject(error);
      }
      winston.debug("Order determined: " + order);
      return Promise.all(order).map(function(task) {
        return load(task, tasks, args);
      });
    };

    return PromiseRunner;

  })();

}).call(this);
